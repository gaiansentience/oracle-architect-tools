create or replace package body dynamic_pivot_etl_unit_testing
as

    procedure test_pipelined
    is
        l_test_set varchar2(100) := 'DYNAMIC TABLE COLUMNS FROM ROW PIVOT  USING PIPELINED OBJECT TYPES AND SUBTYPES';
        l_test_comment varchar2(500);
    begin
    
        dynamic_pivot_test_framework.testing_banner(p_heading => l_test_set, p_start => true);
    
        
        dynamic_pivot_test_framework.testing_headline(p_headline => 'using pipelined function to pivot row name|value pairs from nested tables to object hierarchy');
        dynamic_pivot_test_framework.print_comment(p_comment => 'ROWSOURCE NESTED TABLES TO OBJECT TYPE HIERARCHY');
    
    
    
        dynamic_pivot_test_framework.testing_banner(p_heading => l_test_set, p_start => false);
    
    end test_pipelined;

    procedure test_polymorphic
    is
        l_test_set varchar2(100) := 'DYNAMIC TABLE COLUMNS FROM ROW PIVOT USING POLYMORPHIC TABLE FUNCTIONS';
        l_test_comment varchar2(500); 
        l_timing varchar2(1000);
        l_pivoted_rows number;
        l_pair_values number;
    begin
    
        dynamic_pivot_test_framework.testing_banner(p_heading => l_test_set, p_start => true);
    
        dynamic_pivot_test_framework.testing_headline(p_headline => 'using polymorphic function to pivot row name|value pairs to columns using flat json for name|value pairs');
        dynamic_pivot_test_framework.print_comment(p_comment => 'ROWSOURCE FLAT JSON COLUMNS DYNAMICALLY TYPED TO VARCHAR|NUMBER');
        
        --load the full datasource and delete all pair|values for item_type triangles and regular polygons
        dynamic_pivot_etl.reload_table_pair_value_source(p_execute => true);
        delete from dynamic_pivot_pair_values where item_type in ('triangle', 'regular polygon');
        commit;
        --recreate the table with no columns for triangle or regular polygon
        dynamic_pivot_etl.rebuild_table_polymorphic(p_execute => true);
        --print the current columns
        dynamic_pivot_test_framework.print_columns('dynamic_columns_polymorphic');
        --load the full datasource
        dynamic_pivot_etl.reload_table_pair_value_source(p_execute => true);
        
        dynamic_pivot_test_framework.start_timing;
        --recreate the table with new columns for triangle and regular polygon
        dynamic_pivot_etl.rebuild_table_polymorphic(p_execute => true);
        l_timing := dynamic_pivot_test_framework.stop_timing;
        l_pair_values := dynamic_pivot_test_framework.get_row_count('dynamic_pivot_pair_values');
        l_pivoted_rows := dynamic_pivot_test_framework.get_row_count('dynamic_columns_polymorphic');
        dynamic_pivot_test_framework.print_comment(p_comment => 'pivoted ' || l_pair_values || ' name|value pairs to ' || l_pivoted_rows || '  Timing = ' || l_timing);
        --print the current columns
        dynamic_pivot_test_framework.print_columns('dynamic_columns_polymorphic');

    
        dynamic_pivot_test_framework.testing_banner(p_heading => l_test_set, p_start => false);

    end test_polymorphic;

    procedure run_all_tests
    is
        l_test_set varchar2(100) := 'DYNAMIC TABLE COLUMNS FROM ROW PIVOT COMPARISON: RUN ALL TESTS';
    begin
    
        dynamic_pivot_test_framework.testing_set_banner(p_heading => l_test_set, p_start => true);

        test_polymorphic;
        test_pipelined;
        
        dynamic_pivot_test_framework.testing_set_banner(p_heading => l_test_set, p_start => false);

    end run_all_tests;

begin
    null;
end dynamic_pivot_etl_unit_testing ;
